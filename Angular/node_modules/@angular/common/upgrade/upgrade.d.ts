/**
 * @license Angular v9.0.7
 * (c) 2010-2020 Google LLC. https://angular.io/
 * License: MIT
 */

import { HashLocationStrategy } from '@angular/common';
import { InjectionToken } from '@angular/core';
import { Location } from '@angular/common';
import { LocationStrategy } from '@angular/common';
import { ModuleWithProviders } from '@angular/core';
import { PathLocationStrategy } from '@angular/common';
import { PlatformLocation } from '@angular/common';
import { UpgradeModule } from '@angular/upgrade/static';

/**
 * Location service that provides a drop-in replacement for the $location service
 * provided in AngularJS.
 *
 * @see [Using the Angular Unified Location Service](guide/upgrade#using-the-unified-angular-location-service)
 *
 * @publicApi
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
export declare class $locationShim {
    private location;
    private platformLocation;
    private urlCodec;
    private locationStrategy;
    private initalizing;
    private updateBrowser;
    private $$absUrl;
    private $$url;
    private $$protocol;
    private $$host;
    private $$port;
    private $$replace;
    private $$path;
    private $$search;
    private $$hash;
    private $$state;
    private $$changeListeners;
    private cachedState;
    constructor($injector: any, location: Location, platformLocation: PlatformLocation, urlCodec: UrlCodec, locationStrategy: LocationStrategy);
    private initialize;
    private resetBrowserUpdate;
    private lastHistoryState;
    private lastBrowserUrl;
    private browserUrl;
    private lastCachedState;
    private cacheState;
    /**
     * This function emulates the $browser.state() function from AngularJS. It will cause
     * history.state to be cached unless changed with deep equality check.
     */
    private browserState;
    private stripBaseUrl;
    private getServerBase;
    private parseAppUrl;
    /**
     * Registers listeners for URL changes. This API is used to catch updates performed by the
     * AngularJS framework. These changes are a subset of the `$locationChangeStart` and
     * `$locationChangeSuccess` events which fire when AngularJS updates its internally-referenced
     * version of the browser URL.
     *
     * It's possible for `$locationChange` events to happen, but for the browser URL
     * (window.location) to remain unchanged. This `onChange` callback will fire only when AngularJS
     * actually updates the browser URL (window.location).
     *
     * @param fn The callback function that is triggered for the listener when the URL changes.
     * @param err The callback function that is triggered when an error occurs.
     */
    onChange(fn: (url: string, state: unknown, oldUrl: string, oldState: unknown) => void, err?: (e: Error) => void): void;
    /**
     * Parses the provided URL, and sets the current URL to the parsed result.
     *
     * @param url The URL string.
     */
    $$parse(url: string): void;
    /**
     * Parses the provided URL and its relative URL.
     *
     * @param url The full URL string.
     * @param relHref A URL string relative to the full URL string.
     */
    $$parseLinkUrl(url: string, relHref?: string | null): boolean;
    private setBrowserUrlWithFallback;
    private composeUrls;
    /**
     * Retrieves the full URL representation with all segments encoded according to
     * rules specified in
     * [RFC 3986](http://www.ietf.org/rfc/rfc3986.txt).
     *
     *
     * ```js
     * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo
     * let absUrl = $location.absUrl();
     * // => "http://example.com/#/some/path?foo=bar&baz=xoxo"
     * ```
     */
    absUrl(): string;
    /**
     * Retrieves the current URL, or sets a new URL. When setting a URL,
     * changes the path, search, and hash, and returns a reference to its own instance.
     *
     * ```js
     * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo
     * let url = $location.url();
     * // => "/some/path?foo=bar&baz=xoxo"
     * ```
     */
    url(): string;
    url(url: string): this;
    /**
     * Retrieves the protocol of the current URL.
     *
     * ```js
     * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo
     * let protocol = $location.protocol();
     * // => "http"
     * ```
     */
    protocol(): string;
    /**
     * Retrieves the protocol of the current URL.
     *
     * In contrast to the non-AngularJS version `location.host` which returns `hostname:port`, this
     * returns the `hostname` portion only.
     *
     *
     * ```js
     * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo
     * let host = $location.host();
     * // => "example.com"
     *
     * // given URL http://user:password@example.com:8080/#/some/path?foo=bar&baz=xoxo
     * host = $location.host();
     * // => "example.com"
     * host = location.host;
     * // => "example.com:8080"
     * ```
     */
    host(): string;
    /**
     * Retrieves the port of the current URL.
     *
     * ```js
     * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo
     * let port = $location.port();
     * // => 80
     * ```
     */
    port(): number | null;
    /**
     * Retrieves the path of the current URL, or changes the path and returns a reference to its own
     * instance.
     *
     * Paths should always begin with forward slash (/). This method adds the forward slash
     * if it is missing.
     *
     * ```js
     * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo
     * let path = $location.path();
     * // => "/some/path"
     * ```
     */
    path(): string;
    path(path: string | number | null): this;
    /**
     * Retrieves a map of the search parameters of the current URL, or changes a search
     * part and returns a reference to its own instance.
     *
     *
     * ```js
     * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo
     * let searchObject = $location.search();
     * // => {foo: 'bar', baz: 'xoxo'}
     *
     * // set foo to 'yipee'
     * $location.search('foo', 'yipee');
     * // $location.search() => {foo: 'yipee', baz: 'xoxo'}
     * ```
     *
     * @param {string|Object.<string>|Object.<Array.<string>>} search New search params - string or
     * hash object.
     *
     * When called with a single argument the method acts as a setter, setting the `search` component
     * of `$location` to the specified value.
     *
     * If the argument is a hash object containing an array of values, these values will be encoded
     * as duplicate search parameters in the URL.
     *
     * @param {(string|Number|Array<string>|boolean)=} paramValue If `search` is a string or number, then `paramValue`
     * will override only a single search property.
     *
     * If `paramValue` is an array, it will override the property of the `search` component of
     * `$location` specified via the first argument.
     *
     * If `paramValue` is `null`, the property specified via the first argument will be deleted.
     *
     * If `paramValue` is `true`, the property specified via the first argument will be added with no
     * value nor trailing equal sign.
     *
     * @return {Object} The parsed `search` object of the current URL, or the changed `search` object.
     */
    search(): {
        [key: string]: unknown;
    };
    search(search: string | number | {
        [key: string]: unknown;
    }): this;
    search(search: string | number | {
        [key: string]: unknown;
    }, paramValue: null | undefined | string | number | boolean | string[]): this;
    /**
     * Retrieves the current hash fragment, or changes the hash fragment and returns a reference to
     * its own instance.
     *
     * ```js
     * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo#hashValue
     * let hash = $location.hash();
     * // => "hashValue"
     * ```
     */
    hash(): string;
    hash(hash: string | number | null): this;
    /**
     * Changes to `$location` during the current `$digest` will replace the current
     * history record, instead of adding a new one.
     */
    replace(): this;
    /**
     * Retrieves the history state object when called without any parameter.
     *
     * Change the history state object when called with one parameter and return `$location`.
     * The state object is later passed to `pushState` or `replaceState`.
     *
     * This method is supported only in HTML5 mode and only in browsers supporting
     * the HTML5 History API methods such as `pushState` and `replaceState`. If you need to support
     * older browsers (like IE9 or Android < 4.0), don't use this method.
     *
     */
    state(): unknown;
    state(state: unknown): this;
}

/**
 * The factory function used to create an instance of the `$locationShim` in Angular,
 * and provides an API-compatiable `$locationProvider` for AngularJS.
 *
 * @publicApi
 */
export declare class $locationShimProvider {
    private ngUpgrade;
    private location;
    private platformLocation;
    private urlCodec;
    private locationStrategy;
    constructor(ngUpgrade: UpgradeModule, location: Location, platformLocation: PlatformLocation, urlCodec: UrlCodec, locationStrategy: LocationStrategy);
    /**
     * Factory method that returns an instance of the $locationShim
     */
    $get(): $locationShim;
    /**
     * Stub method used to keep API compatible with AngularJS. This setting is configured through
     * the LocationUpgradeModule's `config` method in your Angular app.
     */
    hashPrefix(prefix?: string): void;
    /**
     * Stub method used to keep API compatible with AngularJS. This setting is configured through
     * the LocationUpgradeModule's `config` method in your Angular app.
     */
    html5Mode(mode?: any): void;
}

/**
 * A `UrlCodec` that uses logic from AngularJS to serialize and parse URLs
 * and URL parameters.
 *
 * @publicApi
 */
export declare class AngularJSUrlCodec implements UrlCodec {
    encodePath(path: string): string;
    encodeSearch(search: string | {
        [k: string]: unknown;
    }): string;
    encodeHash(hash: string): string;
    decodePath(path: string, html5Mode?: boolean): string;
    decodeSearch(search: string): {
        [k: string]: unknown;
    };
    decodeHash(hash: string): string;
    normalize(href: string): string;
    normalize(path: string, search: {
        [k: string]: unknown;
    }, hash: string, baseUrl?: string): string;
    areEqual(valA: string, valB: string): boolean;
    parse(url: string, base?: string): {
        href: string;
        protocol: string;
        host: string;
        search: string;
        hash: string;
        hostname: string;
        port: string;
        pathname: string;
    };
}

/**
 * A provider token used to configure the location upgrade module.
 *
 * @publicApi
 */
export declare const LOCATION_UPGRADE_CONFIGURATION: InjectionToken<LocationUpgradeConfig>;

/**
 * Configuration options for LocationUpgrade.
 *
 * @publicApi
 */
export declare interface LocationUpgradeConfig {
    /**
     * Configures whether the location upgrade module should use the `HashLocationStrategy`
     * or the `PathLocationStrategy`
     */
    useHash?: boolean;
    /**
     * Configures the hash prefix used in the URL when using the `HashLocationStrategy`
     */
    hashPrefix?: string;
    /**
     * Configures the URL codec for encoding and decoding URLs. Default is the `AngularJSCodec`
     */
    urlCodec?: typeof UrlCodec;
    /**
     * Configures the base href when used in server-side rendered applications
     */
    serverBaseHref?: string;
    /**
     * Configures the base href when used in client-side rendered applications
     */
    appBaseHref?: string;
}

/**
 * `NgModule` used for providing and configuring Angular's Unified Location Service for upgrading.
 *
 * @see [Using the Unified Angular Location Service](guide/upgrade#using-the-unified-angular-location-service)
 *
 * @publicApi
 */
export declare class LocationUpgradeModule {
    static config(config?: LocationUpgradeConfig): ModuleWithProviders<LocationUpgradeModule>;
    static ɵmod: ɵngcc0.ɵɵNgModuleDefWithMeta<LocationUpgradeModule, never, [typeof ɵngcc1.CommonModule], never>;
    static ɵinj: ɵngcc0.ɵɵInjectorDef<LocationUpgradeModule>;
}


/**
 * A codec for encoding and decoding URL parts.
 *
 * @publicApi
 **/
export declare abstract class UrlCodec {
    /**
     * Encodes the path from the provided string
     *
     * @param path The path string
     */
    abstract encodePath(path: string): string;
    /**
     * Decodes the path from the provided string
     *
     * @param path The path string
     */
    abstract decodePath(path: string): string;
    /**
     * Encodes the search string from the provided string or object
     *
     * @param path The path string or object
     */
    abstract encodeSearch(search: string | {
        [k: string]: unknown;
    }): string;
    /**
     * Decodes the search objects from the provided string
     *
     * @param path The path string
     */
    abstract decodeSearch(search: string): {
        [k: string]: unknown;
    };
    /**
     * Encodes the hash from the provided string
     *
     * @param path The hash string
     */
    abstract encodeHash(hash: string): string;
    /**
     * Decodes the hash from the provided string
     *
     * @param path The hash string
     */
    abstract decodeHash(hash: string): string;
    /**
     * Normalizes the URL from the provided string
     *
     * @param path The URL string
     */
    abstract normalize(href: string): string;
    /**
     * Normalizes the URL from the provided string, search, hash, and base URL parameters
     *
     * @param path The URL path
     * @param search The search object
     * @param hash The has string
     * @param baseUrl The base URL for the URL
     */
    abstract normalize(path: string, search: {
        [k: string]: unknown;
    }, hash: string, baseUrl?: string): string;
    /**
     * Checks whether the two strings are equal
     * @param valA First string for comparison
     * @param valB Second string for comparison
     */
    abstract areEqual(valA: string, valB: string): boolean;
    /**
     * Parses the URL string based on the base URL
     *
     * @param url The full URL string
     * @param base The base for the URL
     */
    abstract parse(url: string, base?: string): {
        href: string;
        protocol: string;
        host: string;
        search: string;
        hash: string;
        hostname: string;
        port: string;
        pathname: string;
    };
}

export declare function ɵangular_packages_common_upgrade_upgrade_a(config: LocationUpgradeConfig, appBaseHref?: string): string;

export declare function ɵangular_packages_common_upgrade_upgrade_b(config: LocationUpgradeConfig): any;

export declare function ɵangular_packages_common_upgrade_upgrade_c(platformLocation: PlatformLocation, baseHref: string, options?: LocationUpgradeConfig): HashLocationStrategy | PathLocationStrategy;

export declare function ɵangular_packages_common_upgrade_upgrade_d(ngUpgrade: UpgradeModule, location: Location, platformLocation: PlatformLocation, urlCodec: UrlCodec, locationStrategy: LocationStrategy): $locationShim;

export { }

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXBncmFkZS5kLnRzIiwic291cmNlcyI6WyJ1cGdyYWRlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMFVBIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBBbmd1bGFyIHY5LjAuN1xuICogKGMpIDIwMTAtMjAyMCBHb29nbGUgTExDLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuXG5pbXBvcnQgeyBIYXNoTG9jYXRpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IEluamVjdGlvblRva2VuIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IExvY2F0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgTG9jYXRpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IE1vZHVsZVdpdGhQcm92aWRlcnMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgUGF0aExvY2F0aW9uU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBQbGF0Zm9ybUxvY2F0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgVXBncmFkZU1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcclxuXHJcbi8qKlxyXG4gKiBMb2NhdGlvbiBzZXJ2aWNlIHRoYXQgcHJvdmlkZXMgYSBkcm9wLWluIHJlcGxhY2VtZW50IGZvciB0aGUgJGxvY2F0aW9uIHNlcnZpY2VcclxuICogcHJvdmlkZWQgaW4gQW5ndWxhckpTLlxyXG4gKlxyXG4gKiBAc2VlIFtVc2luZyB0aGUgQW5ndWxhciBVbmlmaWVkIExvY2F0aW9uIFNlcnZpY2VdKGd1aWRlL3VwZ3JhZGUjdXNpbmctdGhlLXVuaWZpZWQtYW5ndWxhci1sb2NhdGlvbi1zZXJ2aWNlKVxyXG4gKlxyXG4gKiBAcHVibGljQXBpXHJcbiAqL1xyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyAkbG9jYXRpb25TaGltIHtcclxuICAgIHByaXZhdGUgbG9jYXRpb247XHJcbiAgICBwcml2YXRlIHBsYXRmb3JtTG9jYXRpb247XHJcbiAgICBwcml2YXRlIHVybENvZGVjO1xyXG4gICAgcHJpdmF0ZSBsb2NhdGlvblN0cmF0ZWd5O1xyXG4gICAgcHJpdmF0ZSBpbml0YWxpemluZztcclxuICAgIHByaXZhdGUgdXBkYXRlQnJvd3NlcjtcclxuICAgIHByaXZhdGUgJCRhYnNVcmw7XHJcbiAgICBwcml2YXRlICQkdXJsO1xyXG4gICAgcHJpdmF0ZSAkJHByb3RvY29sO1xyXG4gICAgcHJpdmF0ZSAkJGhvc3Q7XHJcbiAgICBwcml2YXRlICQkcG9ydDtcclxuICAgIHByaXZhdGUgJCRyZXBsYWNlO1xyXG4gICAgcHJpdmF0ZSAkJHBhdGg7XHJcbiAgICBwcml2YXRlICQkc2VhcmNoO1xyXG4gICAgcHJpdmF0ZSAkJGhhc2g7XHJcbiAgICBwcml2YXRlICQkc3RhdGU7XHJcbiAgICBwcml2YXRlICQkY2hhbmdlTGlzdGVuZXJzO1xyXG4gICAgcHJpdmF0ZSBjYWNoZWRTdGF0ZTtcclxuICAgIGNvbnN0cnVjdG9yKCRpbmplY3RvcjogYW55LCBsb2NhdGlvbjogTG9jYXRpb24sIHBsYXRmb3JtTG9jYXRpb246IFBsYXRmb3JtTG9jYXRpb24sIHVybENvZGVjOiBVcmxDb2RlYywgbG9jYXRpb25TdHJhdGVneTogTG9jYXRpb25TdHJhdGVneSk7XHJcbiAgICBwcml2YXRlIGluaXRpYWxpemU7XHJcbiAgICBwcml2YXRlIHJlc2V0QnJvd3NlclVwZGF0ZTtcclxuICAgIHByaXZhdGUgbGFzdEhpc3RvcnlTdGF0ZTtcclxuICAgIHByaXZhdGUgbGFzdEJyb3dzZXJVcmw7XHJcbiAgICBwcml2YXRlIGJyb3dzZXJVcmw7XHJcbiAgICBwcml2YXRlIGxhc3RDYWNoZWRTdGF0ZTtcclxuICAgIHByaXZhdGUgY2FjaGVTdGF0ZTtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBlbXVsYXRlcyB0aGUgJGJyb3dzZXIuc3RhdGUoKSBmdW5jdGlvbiBmcm9tIEFuZ3VsYXJKUy4gSXQgd2lsbCBjYXVzZVxyXG4gICAgICogaGlzdG9yeS5zdGF0ZSB0byBiZSBjYWNoZWQgdW5sZXNzIGNoYW5nZWQgd2l0aCBkZWVwIGVxdWFsaXR5IGNoZWNrLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGJyb3dzZXJTdGF0ZTtcclxuICAgIHByaXZhdGUgc3RyaXBCYXNlVXJsO1xyXG4gICAgcHJpdmF0ZSBnZXRTZXJ2ZXJCYXNlO1xyXG4gICAgcHJpdmF0ZSBwYXJzZUFwcFVybDtcclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJzIGxpc3RlbmVycyBmb3IgVVJMIGNoYW5nZXMuIFRoaXMgQVBJIGlzIHVzZWQgdG8gY2F0Y2ggdXBkYXRlcyBwZXJmb3JtZWQgYnkgdGhlXHJcbiAgICAgKiBBbmd1bGFySlMgZnJhbWV3b3JrLiBUaGVzZSBjaGFuZ2VzIGFyZSBhIHN1YnNldCBvZiB0aGUgYCRsb2NhdGlvbkNoYW5nZVN0YXJ0YCBhbmRcclxuICAgICAqIGAkbG9jYXRpb25DaGFuZ2VTdWNjZXNzYCBldmVudHMgd2hpY2ggZmlyZSB3aGVuIEFuZ3VsYXJKUyB1cGRhdGVzIGl0cyBpbnRlcm5hbGx5LXJlZmVyZW5jZWRcclxuICAgICAqIHZlcnNpb24gb2YgdGhlIGJyb3dzZXIgVVJMLlxyXG4gICAgICpcclxuICAgICAqIEl0J3MgcG9zc2libGUgZm9yIGAkbG9jYXRpb25DaGFuZ2VgIGV2ZW50cyB0byBoYXBwZW4sIGJ1dCBmb3IgdGhlIGJyb3dzZXIgVVJMXHJcbiAgICAgKiAod2luZG93LmxvY2F0aW9uKSB0byByZW1haW4gdW5jaGFuZ2VkLiBUaGlzIGBvbkNoYW5nZWAgY2FsbGJhY2sgd2lsbCBmaXJlIG9ubHkgd2hlbiBBbmd1bGFySlNcclxuICAgICAqIGFjdHVhbGx5IHVwZGF0ZXMgdGhlIGJyb3dzZXIgVVJMICh3aW5kb3cubG9jYXRpb24pLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmbiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyB0cmlnZ2VyZWQgZm9yIHRoZSBsaXN0ZW5lciB3aGVuIHRoZSBVUkwgY2hhbmdlcy5cclxuICAgICAqIEBwYXJhbSBlcnIgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgdHJpZ2dlcmVkIHdoZW4gYW4gZXJyb3Igb2NjdXJzLlxyXG4gICAgICovXHJcbiAgICBvbkNoYW5nZShmbjogKHVybDogc3RyaW5nLCBzdGF0ZTogdW5rbm93biwgb2xkVXJsOiBzdHJpbmcsIG9sZFN0YXRlOiB1bmtub3duKSA9PiB2b2lkLCBlcnI/OiAoZTogRXJyb3IpID0+IHZvaWQpOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgdGhlIHByb3ZpZGVkIFVSTCwgYW5kIHNldHMgdGhlIGN1cnJlbnQgVVJMIHRvIHRoZSBwYXJzZWQgcmVzdWx0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1cmwgVGhlIFVSTCBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgICQkcGFyc2UodXJsOiBzdHJpbmcpOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXMgdGhlIHByb3ZpZGVkIFVSTCBhbmQgaXRzIHJlbGF0aXZlIFVSTC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXJsIFRoZSBmdWxsIFVSTCBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0gcmVsSHJlZiBBIFVSTCBzdHJpbmcgcmVsYXRpdmUgdG8gdGhlIGZ1bGwgVVJMIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgJCRwYXJzZUxpbmtVcmwodXJsOiBzdHJpbmcsIHJlbEhyZWY/OiBzdHJpbmcgfCBudWxsKTogYm9vbGVhbjtcclxuICAgIHByaXZhdGUgc2V0QnJvd3NlclVybFdpdGhGYWxsYmFjaztcclxuICAgIHByaXZhdGUgY29tcG9zZVVybHM7XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgZnVsbCBVUkwgcmVwcmVzZW50YXRpb24gd2l0aCBhbGwgc2VnbWVudHMgZW5jb2RlZCBhY2NvcmRpbmcgdG9cclxuICAgICAqIHJ1bGVzIHNwZWNpZmllZCBpblxyXG4gICAgICogW1JGQyAzOTg2XShodHRwOi8vd3d3LmlldGYub3JnL3JmYy9yZmMzOTg2LnR4dCkuXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiAvLyBnaXZlbiBVUkwgaHR0cDovL2V4YW1wbGUuY29tLyMvc29tZS9wYXRoP2Zvbz1iYXImYmF6PXhveG9cclxuICAgICAqIGxldCBhYnNVcmwgPSAkbG9jYXRpb24uYWJzVXJsKCk7XHJcbiAgICAgKiAvLyA9PiBcImh0dHA6Ly9leGFtcGxlLmNvbS8jL3NvbWUvcGF0aD9mb289YmFyJmJhej14b3hvXCJcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBhYnNVcmwoKTogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnQgVVJMLCBvciBzZXRzIGEgbmV3IFVSTC4gV2hlbiBzZXR0aW5nIGEgVVJMLFxyXG4gICAgICogY2hhbmdlcyB0aGUgcGF0aCwgc2VhcmNoLCBhbmQgaGFzaCwgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG8gaXRzIG93biBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogLy8gZ2l2ZW4gVVJMIGh0dHA6Ly9leGFtcGxlLmNvbS8jL3NvbWUvcGF0aD9mb289YmFyJmJhej14b3hvXHJcbiAgICAgKiBsZXQgdXJsID0gJGxvY2F0aW9uLnVybCgpO1xyXG4gICAgICogLy8gPT4gXCIvc29tZS9wYXRoP2Zvbz1iYXImYmF6PXhveG9cIlxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHVybCgpOiBzdHJpbmc7XHJcbiAgICB1cmwodXJsOiBzdHJpbmcpOiB0aGlzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHByb3RvY29sIG9mIHRoZSBjdXJyZW50IFVSTC5cclxuICAgICAqXHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogLy8gZ2l2ZW4gVVJMIGh0dHA6Ly9leGFtcGxlLmNvbS8jL3NvbWUvcGF0aD9mb289YmFyJmJhej14b3hvXHJcbiAgICAgKiBsZXQgcHJvdG9jb2wgPSAkbG9jYXRpb24ucHJvdG9jb2woKTtcclxuICAgICAqIC8vID0+IFwiaHR0cFwiXHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgcHJvdG9jb2woKTogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHByb3RvY29sIG9mIHRoZSBjdXJyZW50IFVSTC5cclxuICAgICAqXHJcbiAgICAgKiBJbiBjb250cmFzdCB0byB0aGUgbm9uLUFuZ3VsYXJKUyB2ZXJzaW9uIGBsb2NhdGlvbi5ob3N0YCB3aGljaCByZXR1cm5zIGBob3N0bmFtZTpwb3J0YCwgdGhpc1xyXG4gICAgICogcmV0dXJucyB0aGUgYGhvc3RuYW1lYCBwb3J0aW9uIG9ubHkuXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiAvLyBnaXZlbiBVUkwgaHR0cDovL2V4YW1wbGUuY29tLyMvc29tZS9wYXRoP2Zvbz1iYXImYmF6PXhveG9cclxuICAgICAqIGxldCBob3N0ID0gJGxvY2F0aW9uLmhvc3QoKTtcclxuICAgICAqIC8vID0+IFwiZXhhbXBsZS5jb21cIlxyXG4gICAgICpcclxuICAgICAqIC8vIGdpdmVuIFVSTCBodHRwOi8vdXNlcjpwYXNzd29yZEBleGFtcGxlLmNvbTo4MDgwLyMvc29tZS9wYXRoP2Zvbz1iYXImYmF6PXhveG9cclxuICAgICAqIGhvc3QgPSAkbG9jYXRpb24uaG9zdCgpO1xyXG4gICAgICogLy8gPT4gXCJleGFtcGxlLmNvbVwiXHJcbiAgICAgKiBob3N0ID0gbG9jYXRpb24uaG9zdDtcclxuICAgICAqIC8vID0+IFwiZXhhbXBsZS5jb206ODA4MFwiXHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgaG9zdCgpOiBzdHJpbmc7XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgcG9ydCBvZiB0aGUgY3VycmVudCBVUkwuXHJcbiAgICAgKlxyXG4gICAgICogYGBganNcclxuICAgICAqIC8vIGdpdmVuIFVSTCBodHRwOi8vZXhhbXBsZS5jb20vIy9zb21lL3BhdGg/Zm9vPWJhciZiYXo9eG94b1xyXG4gICAgICogbGV0IHBvcnQgPSAkbG9jYXRpb24ucG9ydCgpO1xyXG4gICAgICogLy8gPT4gODBcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBwb3J0KCk6IG51bWJlciB8IG51bGw7XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgcGF0aCBvZiB0aGUgY3VycmVudCBVUkwsIG9yIGNoYW5nZXMgdGhlIHBhdGggYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG8gaXRzIG93blxyXG4gICAgICogaW5zdGFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogUGF0aHMgc2hvdWxkIGFsd2F5cyBiZWdpbiB3aXRoIGZvcndhcmQgc2xhc2ggKC8pLiBUaGlzIG1ldGhvZCBhZGRzIHRoZSBmb3J3YXJkIHNsYXNoXHJcbiAgICAgKiBpZiBpdCBpcyBtaXNzaW5nLlxyXG4gICAgICpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiAvLyBnaXZlbiBVUkwgaHR0cDovL2V4YW1wbGUuY29tLyMvc29tZS9wYXRoP2Zvbz1iYXImYmF6PXhveG9cclxuICAgICAqIGxldCBwYXRoID0gJGxvY2F0aW9uLnBhdGgoKTtcclxuICAgICAqIC8vID0+IFwiL3NvbWUvcGF0aFwiXHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgcGF0aCgpOiBzdHJpbmc7XHJcbiAgICBwYXRoKHBhdGg6IHN0cmluZyB8IG51bWJlciB8IG51bGwpOiB0aGlzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYSBtYXAgb2YgdGhlIHNlYXJjaCBwYXJhbWV0ZXJzIG9mIHRoZSBjdXJyZW50IFVSTCwgb3IgY2hhbmdlcyBhIHNlYXJjaFxyXG4gICAgICogcGFydCBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0byBpdHMgb3duIGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqXHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogLy8gZ2l2ZW4gVVJMIGh0dHA6Ly9leGFtcGxlLmNvbS8jL3NvbWUvcGF0aD9mb289YmFyJmJhej14b3hvXHJcbiAgICAgKiBsZXQgc2VhcmNoT2JqZWN0ID0gJGxvY2F0aW9uLnNlYXJjaCgpO1xyXG4gICAgICogLy8gPT4ge2ZvbzogJ2JhcicsIGJhejogJ3hveG8nfVxyXG4gICAgICpcclxuICAgICAqIC8vIHNldCBmb28gdG8gJ3lpcGVlJ1xyXG4gICAgICogJGxvY2F0aW9uLnNlYXJjaCgnZm9vJywgJ3lpcGVlJyk7XHJcbiAgICAgKiAvLyAkbG9jYXRpb24uc2VhcmNoKCkgPT4ge2ZvbzogJ3lpcGVlJywgYmF6OiAneG94byd9XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3QuPHN0cmluZz58T2JqZWN0LjxBcnJheS48c3RyaW5nPj59IHNlYXJjaCBOZXcgc2VhcmNoIHBhcmFtcyAtIHN0cmluZyBvclxyXG4gICAgICogaGFzaCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogV2hlbiBjYWxsZWQgd2l0aCBhIHNpbmdsZSBhcmd1bWVudCB0aGUgbWV0aG9kIGFjdHMgYXMgYSBzZXR0ZXIsIHNldHRpbmcgdGhlIGBzZWFyY2hgIGNvbXBvbmVudFxyXG4gICAgICogb2YgYCRsb2NhdGlvbmAgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZS5cclxuICAgICAqXHJcbiAgICAgKiBJZiB0aGUgYXJndW1lbnQgaXMgYSBoYXNoIG9iamVjdCBjb250YWluaW5nIGFuIGFycmF5IG9mIHZhbHVlcywgdGhlc2UgdmFsdWVzIHdpbGwgYmUgZW5jb2RlZFxyXG4gICAgICogYXMgZHVwbGljYXRlIHNlYXJjaCBwYXJhbWV0ZXJzIGluIHRoZSBVUkwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfE51bWJlcnxBcnJheTxzdHJpbmc+fGJvb2xlYW4pPX0gcGFyYW1WYWx1ZSBJZiBgc2VhcmNoYCBpcyBhIHN0cmluZyBvciBudW1iZXIsIHRoZW4gYHBhcmFtVmFsdWVgXHJcbiAgICAgKiB3aWxsIG92ZXJyaWRlIG9ubHkgYSBzaW5nbGUgc2VhcmNoIHByb3BlcnR5LlxyXG4gICAgICpcclxuICAgICAqIElmIGBwYXJhbVZhbHVlYCBpcyBhbiBhcnJheSwgaXQgd2lsbCBvdmVycmlkZSB0aGUgcHJvcGVydHkgb2YgdGhlIGBzZWFyY2hgIGNvbXBvbmVudCBvZlxyXG4gICAgICogYCRsb2NhdGlvbmAgc3BlY2lmaWVkIHZpYSB0aGUgZmlyc3QgYXJndW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogSWYgYHBhcmFtVmFsdWVgIGlzIGBudWxsYCwgdGhlIHByb3BlcnR5IHNwZWNpZmllZCB2aWEgdGhlIGZpcnN0IGFyZ3VtZW50IHdpbGwgYmUgZGVsZXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBJZiBgcGFyYW1WYWx1ZWAgaXMgYHRydWVgLCB0aGUgcHJvcGVydHkgc3BlY2lmaWVkIHZpYSB0aGUgZmlyc3QgYXJndW1lbnQgd2lsbCBiZSBhZGRlZCB3aXRoIG5vXHJcbiAgICAgKiB2YWx1ZSBub3IgdHJhaWxpbmcgZXF1YWwgc2lnbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBwYXJzZWQgYHNlYXJjaGAgb2JqZWN0IG9mIHRoZSBjdXJyZW50IFVSTCwgb3IgdGhlIGNoYW5nZWQgYHNlYXJjaGAgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBzZWFyY2goKToge1xyXG4gICAgICAgIFtrZXk6IHN0cmluZ106IHVua25vd247XHJcbiAgICB9O1xyXG4gICAgc2VhcmNoKHNlYXJjaDogc3RyaW5nIHwgbnVtYmVyIHwge1xyXG4gICAgICAgIFtrZXk6IHN0cmluZ106IHVua25vd247XHJcbiAgICB9KTogdGhpcztcclxuICAgIHNlYXJjaChzZWFyY2g6IHN0cmluZyB8IG51bWJlciB8IHtcclxuICAgICAgICBba2V5OiBzdHJpbmddOiB1bmtub3duO1xyXG4gICAgfSwgcGFyYW1WYWx1ZTogbnVsbCB8IHVuZGVmaW5lZCB8IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBzdHJpbmdbXSk6IHRoaXM7XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgY3VycmVudCBoYXNoIGZyYWdtZW50LCBvciBjaGFuZ2VzIHRoZSBoYXNoIGZyYWdtZW50IGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvXHJcbiAgICAgKiBpdHMgb3duIGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiAvLyBnaXZlbiBVUkwgaHR0cDovL2V4YW1wbGUuY29tLyMvc29tZS9wYXRoP2Zvbz1iYXImYmF6PXhveG8jaGFzaFZhbHVlXHJcbiAgICAgKiBsZXQgaGFzaCA9ICRsb2NhdGlvbi5oYXNoKCk7XHJcbiAgICAgKiAvLyA9PiBcImhhc2hWYWx1ZVwiXHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgaGFzaCgpOiBzdHJpbmc7XHJcbiAgICBoYXNoKGhhc2g6IHN0cmluZyB8IG51bWJlciB8IG51bGwpOiB0aGlzO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHRvIGAkbG9jYXRpb25gIGR1cmluZyB0aGUgY3VycmVudCBgJGRpZ2VzdGAgd2lsbCByZXBsYWNlIHRoZSBjdXJyZW50XHJcbiAgICAgKiBoaXN0b3J5IHJlY29yZCwgaW5zdGVhZCBvZiBhZGRpbmcgYSBuZXcgb25lLlxyXG4gICAgICovXHJcbiAgICByZXBsYWNlKCk6IHRoaXM7XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgaGlzdG9yeSBzdGF0ZSBvYmplY3Qgd2hlbiBjYWxsZWQgd2l0aG91dCBhbnkgcGFyYW1ldGVyLlxyXG4gICAgICpcclxuICAgICAqIENoYW5nZSB0aGUgaGlzdG9yeSBzdGF0ZSBvYmplY3Qgd2hlbiBjYWxsZWQgd2l0aCBvbmUgcGFyYW1ldGVyIGFuZCByZXR1cm4gYCRsb2NhdGlvbmAuXHJcbiAgICAgKiBUaGUgc3RhdGUgb2JqZWN0IGlzIGxhdGVyIHBhc3NlZCB0byBgcHVzaFN0YXRlYCBvciBgcmVwbGFjZVN0YXRlYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBzdXBwb3J0ZWQgb25seSBpbiBIVE1MNSBtb2RlIGFuZCBvbmx5IGluIGJyb3dzZXJzIHN1cHBvcnRpbmdcclxuICAgICAqIHRoZSBIVE1MNSBIaXN0b3J5IEFQSSBtZXRob2RzIHN1Y2ggYXMgYHB1c2hTdGF0ZWAgYW5kIGByZXBsYWNlU3RhdGVgLiBJZiB5b3UgbmVlZCB0byBzdXBwb3J0XHJcbiAgICAgKiBvbGRlciBicm93c2VycyAobGlrZSBJRTkgb3IgQW5kcm9pZCA8IDQuMCksIGRvbid0IHVzZSB0aGlzIG1ldGhvZC5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHN0YXRlKCk6IHVua25vd247XHJcbiAgICBzdGF0ZShzdGF0ZTogdW5rbm93bik6IHRoaXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgZmFjdG9yeSBmdW5jdGlvbiB1c2VkIHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGUgYCRsb2NhdGlvblNoaW1gIGluIEFuZ3VsYXIsXHJcbiAqIGFuZCBwcm92aWRlcyBhbiBBUEktY29tcGF0aWFibGUgYCRsb2NhdGlvblByb3ZpZGVyYCBmb3IgQW5ndWxhckpTLlxyXG4gKlxyXG4gKiBAcHVibGljQXBpXHJcbiAqL1xyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyAkbG9jYXRpb25TaGltUHJvdmlkZXIge1xyXG4gICAgcHJpdmF0ZSBuZ1VwZ3JhZGU7XHJcbiAgICBwcml2YXRlIGxvY2F0aW9uO1xyXG4gICAgcHJpdmF0ZSBwbGF0Zm9ybUxvY2F0aW9uO1xyXG4gICAgcHJpdmF0ZSB1cmxDb2RlYztcclxuICAgIHByaXZhdGUgbG9jYXRpb25TdHJhdGVneTtcclxuICAgIGNvbnN0cnVjdG9yKG5nVXBncmFkZTogVXBncmFkZU1vZHVsZSwgbG9jYXRpb246IExvY2F0aW9uLCBwbGF0Zm9ybUxvY2F0aW9uOiBQbGF0Zm9ybUxvY2F0aW9uLCB1cmxDb2RlYzogVXJsQ29kZWMsIGxvY2F0aW9uU3RyYXRlZ3k6IExvY2F0aW9uU3RyYXRlZ3kpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBGYWN0b3J5IG1ldGhvZCB0aGF0IHJldHVybnMgYW4gaW5zdGFuY2Ugb2YgdGhlICRsb2NhdGlvblNoaW1cclxuICAgICAqL1xyXG4gICAgJGdldCgpOiAkbG9jYXRpb25TaGltO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdHViIG1ldGhvZCB1c2VkIHRvIGtlZXAgQVBJIGNvbXBhdGlibGUgd2l0aCBBbmd1bGFySlMuIFRoaXMgc2V0dGluZyBpcyBjb25maWd1cmVkIHRocm91Z2hcclxuICAgICAqIHRoZSBMb2NhdGlvblVwZ3JhZGVNb2R1bGUncyBgY29uZmlnYCBtZXRob2QgaW4geW91ciBBbmd1bGFyIGFwcC5cclxuICAgICAqL1xyXG4gICAgaGFzaFByZWZpeChwcmVmaXg/OiBzdHJpbmcpOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdHViIG1ldGhvZCB1c2VkIHRvIGtlZXAgQVBJIGNvbXBhdGlibGUgd2l0aCBBbmd1bGFySlMuIFRoaXMgc2V0dGluZyBpcyBjb25maWd1cmVkIHRocm91Z2hcclxuICAgICAqIHRoZSBMb2NhdGlvblVwZ3JhZGVNb2R1bGUncyBgY29uZmlnYCBtZXRob2QgaW4geW91ciBBbmd1bGFyIGFwcC5cclxuICAgICAqL1xyXG4gICAgaHRtbDVNb2RlKG1vZGU/OiBhbnkpOiB2b2lkO1xyXG59XHJcblxyXG4vKipcclxuICogQSBgVXJsQ29kZWNgIHRoYXQgdXNlcyBsb2dpYyBmcm9tIEFuZ3VsYXJKUyB0byBzZXJpYWxpemUgYW5kIHBhcnNlIFVSTHNcclxuICogYW5kIFVSTCBwYXJhbWV0ZXJzLlxyXG4gKlxyXG4gKiBAcHVibGljQXBpXHJcbiAqL1xyXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBBbmd1bGFySlNVcmxDb2RlYyBpbXBsZW1lbnRzIFVybENvZGVjIHtcclxuICAgIGVuY29kZVBhdGgocGF0aDogc3RyaW5nKTogc3RyaW5nO1xyXG4gICAgZW5jb2RlU2VhcmNoKHNlYXJjaDogc3RyaW5nIHwge1xyXG4gICAgICAgIFtrOiBzdHJpbmddOiB1bmtub3duO1xyXG4gICAgfSk6IHN0cmluZztcclxuICAgIGVuY29kZUhhc2goaGFzaDogc3RyaW5nKTogc3RyaW5nO1xyXG4gICAgZGVjb2RlUGF0aChwYXRoOiBzdHJpbmcsIGh0bWw1TW9kZT86IGJvb2xlYW4pOiBzdHJpbmc7XHJcbiAgICBkZWNvZGVTZWFyY2goc2VhcmNoOiBzdHJpbmcpOiB7XHJcbiAgICAgICAgW2s6IHN0cmluZ106IHVua25vd247XHJcbiAgICB9O1xyXG4gICAgZGVjb2RlSGFzaChoYXNoOiBzdHJpbmcpOiBzdHJpbmc7XHJcbiAgICBub3JtYWxpemUoaHJlZjogc3RyaW5nKTogc3RyaW5nO1xyXG4gICAgbm9ybWFsaXplKHBhdGg6IHN0cmluZywgc2VhcmNoOiB7XHJcbiAgICAgICAgW2s6IHN0cmluZ106IHVua25vd247XHJcbiAgICB9LCBoYXNoOiBzdHJpbmcsIGJhc2VVcmw/OiBzdHJpbmcpOiBzdHJpbmc7XHJcbiAgICBhcmVFcXVhbCh2YWxBOiBzdHJpbmcsIHZhbEI6IHN0cmluZyk6IGJvb2xlYW47XHJcbiAgICBwYXJzZSh1cmw6IHN0cmluZywgYmFzZT86IHN0cmluZyk6IHtcclxuICAgICAgICBocmVmOiBzdHJpbmc7XHJcbiAgICAgICAgcHJvdG9jb2w6IHN0cmluZztcclxuICAgICAgICBob3N0OiBzdHJpbmc7XHJcbiAgICAgICAgc2VhcmNoOiBzdHJpbmc7XHJcbiAgICAgICAgaGFzaDogc3RyaW5nO1xyXG4gICAgICAgIGhvc3RuYW1lOiBzdHJpbmc7XHJcbiAgICAgICAgcG9ydDogc3RyaW5nO1xyXG4gICAgICAgIHBhdGhuYW1lOiBzdHJpbmc7XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQSBwcm92aWRlciB0b2tlbiB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUgbG9jYXRpb24gdXBncmFkZSBtb2R1bGUuXHJcbiAqXHJcbiAqIEBwdWJsaWNBcGlcclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIGNvbnN0IExPQ0FUSU9OX1VQR1JBREVfQ09ORklHVVJBVElPTjogSW5qZWN0aW9uVG9rZW48TG9jYXRpb25VcGdyYWRlQ29uZmlnPjtcclxuXHJcbi8qKlxyXG4gKiBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIExvY2F0aW9uVXBncmFkZS5cclxuICpcclxuICogQHB1YmxpY0FwaVxyXG4gKi9cclxuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIExvY2F0aW9uVXBncmFkZUNvbmZpZyB7XHJcbiAgICAvKipcclxuICAgICAqIENvbmZpZ3VyZXMgd2hldGhlciB0aGUgbG9jYXRpb24gdXBncmFkZSBtb2R1bGUgc2hvdWxkIHVzZSB0aGUgYEhhc2hMb2NhdGlvblN0cmF0ZWd5YFxyXG4gICAgICogb3IgdGhlIGBQYXRoTG9jYXRpb25TdHJhdGVneWBcclxuICAgICAqL1xyXG4gICAgdXNlSGFzaD86IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIENvbmZpZ3VyZXMgdGhlIGhhc2ggcHJlZml4IHVzZWQgaW4gdGhlIFVSTCB3aGVuIHVzaW5nIHRoZSBgSGFzaExvY2F0aW9uU3RyYXRlZ3lgXHJcbiAgICAgKi9cclxuICAgIGhhc2hQcmVmaXg/OiBzdHJpbmc7XHJcbiAgICAvKipcclxuICAgICAqIENvbmZpZ3VyZXMgdGhlIFVSTCBjb2RlYyBmb3IgZW5jb2RpbmcgYW5kIGRlY29kaW5nIFVSTHMuIERlZmF1bHQgaXMgdGhlIGBBbmd1bGFySlNDb2RlY2BcclxuICAgICAqL1xyXG4gICAgdXJsQ29kZWM/OiB0eXBlb2YgVXJsQ29kZWM7XHJcbiAgICAvKipcclxuICAgICAqIENvbmZpZ3VyZXMgdGhlIGJhc2UgaHJlZiB3aGVuIHVzZWQgaW4gc2VydmVyLXNpZGUgcmVuZGVyZWQgYXBwbGljYXRpb25zXHJcbiAgICAgKi9cclxuICAgIHNlcnZlckJhc2VIcmVmPzogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25maWd1cmVzIHRoZSBiYXNlIGhyZWYgd2hlbiB1c2VkIGluIGNsaWVudC1zaWRlIHJlbmRlcmVkIGFwcGxpY2F0aW9uc1xyXG4gICAgICovXHJcbiAgICBhcHBCYXNlSHJlZj86IHN0cmluZztcclxufVxyXG5cclxuLyoqXHJcbiAqIGBOZ01vZHVsZWAgdXNlZCBmb3IgcHJvdmlkaW5nIGFuZCBjb25maWd1cmluZyBBbmd1bGFyJ3MgVW5pZmllZCBMb2NhdGlvbiBTZXJ2aWNlIGZvciB1cGdyYWRpbmcuXHJcbiAqXHJcbiAqIEBzZWUgW1VzaW5nIHRoZSBVbmlmaWVkIEFuZ3VsYXIgTG9jYXRpb24gU2VydmljZV0oZ3VpZGUvdXBncmFkZSN1c2luZy10aGUtdW5pZmllZC1hbmd1bGFyLWxvY2F0aW9uLXNlcnZpY2UpXHJcbiAqXHJcbiAqIEBwdWJsaWNBcGlcclxuICovXHJcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIExvY2F0aW9uVXBncmFkZU1vZHVsZSB7XHJcbiAgICBzdGF0aWMgY29uZmlnKGNvbmZpZz86IExvY2F0aW9uVXBncmFkZUNvbmZpZyk6IE1vZHVsZVdpdGhQcm92aWRlcnM8TG9jYXRpb25VcGdyYWRlTW9kdWxlPjtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBBIGNvZGVjIGZvciBlbmNvZGluZyBhbmQgZGVjb2RpbmcgVVJMIHBhcnRzLlxyXG4gKlxyXG4gKiBAcHVibGljQXBpXHJcbiAqKi9cclxuZXhwb3J0IGRlY2xhcmUgYWJzdHJhY3QgY2xhc3MgVXJsQ29kZWMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbmNvZGVzIHRoZSBwYXRoIGZyb20gdGhlIHByb3ZpZGVkIHN0cmluZ1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHN0cmluZ1xyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBlbmNvZGVQYXRoKHBhdGg6IHN0cmluZyk6IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlcyB0aGUgcGF0aCBmcm9tIHRoZSBwcm92aWRlZCBzdHJpbmdcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCBzdHJpbmdcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgZGVjb2RlUGF0aChwYXRoOiBzdHJpbmcpOiBzdHJpbmc7XHJcbiAgICAvKipcclxuICAgICAqIEVuY29kZXMgdGhlIHNlYXJjaCBzdHJpbmcgZnJvbSB0aGUgcHJvdmlkZWQgc3RyaW5nIG9yIG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwYXRoIHN0cmluZyBvciBvYmplY3RcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgZW5jb2RlU2VhcmNoKHNlYXJjaDogc3RyaW5nIHwge1xyXG4gICAgICAgIFtrOiBzdHJpbmddOiB1bmtub3duO1xyXG4gICAgfSk6IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlcyB0aGUgc2VhcmNoIG9iamVjdHMgZnJvbSB0aGUgcHJvdmlkZWQgc3RyaW5nXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhdGggVGhlIHBhdGggc3RyaW5nXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGRlY29kZVNlYXJjaChzZWFyY2g6IHN0cmluZyk6IHtcclxuICAgICAgICBbazogc3RyaW5nXTogdW5rbm93bjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEVuY29kZXMgdGhlIGhhc2ggZnJvbSB0aGUgcHJvdmlkZWQgc3RyaW5nXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhdGggVGhlIGhhc2ggc3RyaW5nXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGVuY29kZUhhc2goaGFzaDogc3RyaW5nKTogc3RyaW5nO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvZGVzIHRoZSBoYXNoIGZyb20gdGhlIHByb3ZpZGVkIHN0cmluZ1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBoYXNoIHN0cmluZ1xyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBkZWNvZGVIYXNoKGhhc2g6IHN0cmluZyk6IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogTm9ybWFsaXplcyB0aGUgVVJMIGZyb20gdGhlIHByb3ZpZGVkIHN0cmluZ1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBVUkwgc3RyaW5nXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IG5vcm1hbGl6ZShocmVmOiBzdHJpbmcpOiBzdHJpbmc7XHJcbiAgICAvKipcclxuICAgICAqIE5vcm1hbGl6ZXMgdGhlIFVSTCBmcm9tIHRoZSBwcm92aWRlZCBzdHJpbmcsIHNlYXJjaCwgaGFzaCwgYW5kIGJhc2UgVVJMIHBhcmFtZXRlcnNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgVVJMIHBhdGhcclxuICAgICAqIEBwYXJhbSBzZWFyY2ggVGhlIHNlYXJjaCBvYmplY3RcclxuICAgICAqIEBwYXJhbSBoYXNoIFRoZSBoYXMgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0gYmFzZVVybCBUaGUgYmFzZSBVUkwgZm9yIHRoZSBVUkxcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3Qgbm9ybWFsaXplKHBhdGg6IHN0cmluZywgc2VhcmNoOiB7XHJcbiAgICAgICAgW2s6IHN0cmluZ106IHVua25vd247XHJcbiAgICB9LCBoYXNoOiBzdHJpbmcsIGJhc2VVcmw/OiBzdHJpbmcpOiBzdHJpbmc7XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSB0d28gc3RyaW5ncyBhcmUgZXF1YWxcclxuICAgICAqIEBwYXJhbSB2YWxBIEZpcnN0IHN0cmluZyBmb3IgY29tcGFyaXNvblxyXG4gICAgICogQHBhcmFtIHZhbEIgU2Vjb25kIHN0cmluZyBmb3IgY29tcGFyaXNvblxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBhcmVFcXVhbCh2YWxBOiBzdHJpbmcsIHZhbEI6IHN0cmluZyk6IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlcyB0aGUgVVJMIHN0cmluZyBiYXNlZCBvbiB0aGUgYmFzZSBVUkxcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXJsIFRoZSBmdWxsIFVSTCBzdHJpbmdcclxuICAgICAqIEBwYXJhbSBiYXNlIFRoZSBiYXNlIGZvciB0aGUgVVJMXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IHBhcnNlKHVybDogc3RyaW5nLCBiYXNlPzogc3RyaW5nKToge1xyXG4gICAgICAgIGhyZWY6IHN0cmluZztcclxuICAgICAgICBwcm90b2NvbDogc3RyaW5nO1xyXG4gICAgICAgIGhvc3Q6IHN0cmluZztcclxuICAgICAgICBzZWFyY2g6IHN0cmluZztcclxuICAgICAgICBoYXNoOiBzdHJpbmc7XHJcbiAgICAgICAgaG9zdG5hbWU6IHN0cmluZztcclxuICAgICAgICBwb3J0OiBzdHJpbmc7XHJcbiAgICAgICAgcGF0aG5hbWU6IHN0cmluZztcclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIMm1YW5ndWxhcl9wYWNrYWdlc19jb21tb25fdXBncmFkZV91cGdyYWRlX2EoY29uZmlnOiBMb2NhdGlvblVwZ3JhZGVDb25maWcsIGFwcEJhc2VIcmVmPzogc3RyaW5nKTogc3RyaW5nO1xyXG5cclxuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gybVhbmd1bGFyX3BhY2thZ2VzX2NvbW1vbl91cGdyYWRlX3VwZ3JhZGVfYihjb25maWc6IExvY2F0aW9uVXBncmFkZUNvbmZpZyk6IGFueTtcclxuXHJcbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIMm1YW5ndWxhcl9wYWNrYWdlc19jb21tb25fdXBncmFkZV91cGdyYWRlX2MocGxhdGZvcm1Mb2NhdGlvbjogUGxhdGZvcm1Mb2NhdGlvbiwgYmFzZUhyZWY6IHN0cmluZywgb3B0aW9ucz86IExvY2F0aW9uVXBncmFkZUNvbmZpZyk6IEhhc2hMb2NhdGlvblN0cmF0ZWd5IHwgUGF0aExvY2F0aW9uU3RyYXRlZ3k7XHJcblxyXG5leHBvcnQgZGVjbGFyZSBmdW5jdGlvbiDJtWFuZ3VsYXJfcGFja2FnZXNfY29tbW9uX3VwZ3JhZGVfdXBncmFkZV9kKG5nVXBncmFkZTogVXBncmFkZU1vZHVsZSwgbG9jYXRpb246IExvY2F0aW9uLCBwbGF0Zm9ybUxvY2F0aW9uOiBQbGF0Zm9ybUxvY2F0aW9uLCB1cmxDb2RlYzogVXJsQ29kZWMsIGxvY2F0aW9uU3RyYXRlZ3k6IExvY2F0aW9uU3RyYXRlZ3kpOiAkbG9jYXRpb25TaGltO1xyXG5cclxuZXhwb3J0IHsgfVxyXG4iXX0=